{"version":3,"file":"static/js/2701.e78f59a3.chunk.js","mappings":"gIAQA,SAASA,EAAIC,EAAYC,GAAuC,IAAtBC,EAAYC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,IAAAA,UAAA,GAClD,GAAIH,aAAsBM,aAAeL,EAAgBD,GACrD,OAAOA,EAEX,MAAMO,EAAgBP,aAAsBQ,gBACtCR,EAAWS,iBAAiB,CAAEC,SAAS,IACvCC,MAAMC,KAAKZ,EAAWa,UACxBX,GAAgBF,aAAsBM,aAAeN,EAAWc,YAChEP,EAAcQ,QAAQJ,MAAMC,KAAKZ,EAAWc,WAAWD,WAE3D,IAAIG,EAAe,KAKnB,OAJAT,EAAcU,MAAMC,IAChBF,EAAejB,EAAImB,EAAOjB,EAAiBC,GACnB,OAAjBc,KAEJA,CACX,C,0HCrBA,MAGMG,EAAoB,MACtBC,WAAAA,CAAYC,IACRC,EAAAA,EAAAA,GAAiBC,KAAMF,EAC3B,CACAG,MAAAA,GACI,OAAQC,EAAAA,EAAAA,GAAEC,EAAAA,EAAM,CAAEC,IAAK,6CAA8CF,EAAAA,EAAAA,GAAE,MAAO,CAAEE,IAAK,2CAA4CC,MAAO,SAAUH,EAAAA,EAAAA,GAAE,OAAQ,CAAEE,IAAK,8CACvK,GAEJR,EAAkBU,MAXQ,0YAa1B,MAGMC,EAAgB,MAClBV,WAAAA,CAAYC,IACRC,EAAAA,EAAAA,GAAiBC,KAAMF,GACvBE,KAAKQ,QAAS,EACdR,KAAKS,UAAW,CACpB,CACAC,aAAAA,CAAchC,EAAiBiC,GAC3B,MACMC,EADmBZ,KAAKa,OAAO3B,iBAAiB,CAAEC,SAAS,IACpB,GAC7C,GAAIyB,EAAqB,CACrB,MAAMnB,GAAejB,EAAAA,EAAAA,GAAIoC,EAAqBlC,GAC1Ce,GACAkB,EAAiBlB,EAEzB,CACJ,CAIAqB,qBAAAA,GACI,GAAId,KAAKa,OAAQ,CACb,MAAME,EAAeC,GAA8C,aAAlCA,EAAQC,QAAQC,eAAkE,QAAlCF,EAAQC,QAAQC,cAC3FC,EAAgBH,GAAYA,EAAQI,UAAUC,IAAI,0BACxDrB,KAAKU,cAAcK,EAAaI,GAChC,MAAMG,EAAWN,GAA8C,QAAlCA,EAAQC,QAAQC,cACvCK,EAAiBP,GAAYA,EAAQI,UAAUC,IAAI,2BACzDrB,KAAKU,cAAcY,EAASC,EAChC,CACJ,CACAC,gBAAAA,GACIxB,KAAKa,OAASb,KAAKyB,KAAKlC,WAAWmC,cAAc,QACjD1B,KAAKc,wBACLd,KAAKa,OAAOc,iBAAiB,aAAc3B,KAAKc,sBACpD,CACAb,MAAAA,GACI,OAAQC,EAAAA,EAAAA,GAAEC,EAAAA,EAAM,CAAEC,IAAK,6CAA8CF,EAAAA,EAAAA,GAAE,uBAAwB,CAAEE,IAAK,2CAA4CC,MAAO,CACjJ,mBAAoBL,KAAKQ,OACzB,qBAAsBR,KAAKS,YAC1BP,EAAAA,EAAAA,GAAE,OAAQ,CAAEE,IAAK,8CAC9B,CACA,QAAIqB,GAAS,OAAOG,EAAAA,EAAAA,GAAW5B,KAAO,GAE1CO,EAAcD,MA7CQ,yoC","sources":["../node_modules/@scania/tegel/dist/esm/dfs-1e574d5f.js","../node_modules/@scania/tegel/dist/esm/tds-core-header-item_2.entry.js"],"sourcesContent":["/**\n * Recursively finds the first matching element or child based on a provided condition.\n *\n * @param {ParentNode} parentNode - The starting element or shadow root to search from.\n * @param {(el: HTMLElement) => boolean} searchPredicate - The condition to match the element, receives an HTMLElement and returns a boolean.\n * @param {boolean} [pierceShadow=false] - Whether to pierce through shadow DOM boundaries.\n * @returns {HTMLElement | null} - The first matching element or child, or null if none is found.\n */\nfunction dfs(parentNode, searchPredicate, pierceShadow = false) {\n    if (parentNode instanceof HTMLElement && searchPredicate(parentNode)) {\n        return parentNode;\n    }\n    const childElements = parentNode instanceof HTMLSlotElement\n        ? parentNode.assignedElements({ flatten: true })\n        : Array.from(parentNode.children);\n    if (pierceShadow && parentNode instanceof HTMLElement && parentNode.shadowRoot) {\n        childElements.push(...Array.from(parentNode.shadowRoot.children));\n    }\n    let foundElement = null;\n    childElements.some((child) => {\n        foundElement = dfs(child, searchPredicate, pierceShadow);\n        return foundElement !== null;\n    });\n    return foundElement;\n}\n\nexport { dfs as d };\n","import { r as registerInstance, h, H as Host, g as getElement } from './index-529974bd.js';\nimport { d as dfs } from './dfs-1e574d5f.js';\n\nconst coreHeaderItemCss = \":host{font:var(--tds-headline-07);letter-spacing:var(--tds-headline-07-ls);color:var(--tds-header-nav-item-color)}:host .item{all:unset;box-sizing:border-box;display:flex;justify-content:center;align-items:center;min-width:var(--tds-header-height);height:var(--tds-header-height);margin:0}:host .item *{box-sizing:border-box}:host slot{white-space:nowrap}:host ::slotted(svg){font-size:20px}\";\nconst TdsCoreHeaderItemStyle0 = coreHeaderItemCss;\n\nconst TdsCoreHeaderItem = class {\n    constructor(hostRef) {\n        registerInstance(this, hostRef);\n    }\n    render() {\n        return (h(Host, { key: '5518d7a3359d48ac323fa1a87e9c014911deb806' }, h(\"div\", { key: '9d6ae88a87fdfecf92df14095b8bd5b844a1ff41', class: \"item\" }, h(\"slot\", { key: 'cd3045dc6b892cb19c8d489e341897ff298be743' }))));\n    }\n};\nTdsCoreHeaderItem.style = TdsCoreHeaderItemStyle0;\n\nconst headerItemCss = \":host ::slotted(button),:host ::slotted(a){all:unset;box-sizing:border-box;background-color:var(--tds-header-background);border-right:1px solid var(--tds-header--basic-element-border);width:100%;height:100%;cursor:pointer;padding:0 24px;display:flex;align-items:center;gap:8px}:host ::slotted(button) *,:host ::slotted(a) *{box-sizing:border-box}:host ::slotted(button:hover),:host ::slotted(a:hover){background-color:var(--tds-header-item-hover)}:host ::slotted(button:focus-visible),:host ::slotted(a:focus-visible){outline:2px solid var(--tds-blue-400);outline-offset:-2px}:host .component-active ::slotted(button),:host .component-active ::slotted(a){background-color:var(--tds-header--basic-element-background-open);color:var(--tds-header-nav-item-dropdown-opened-color);border-color:var(--tds-header--basic-element-border-open)}:host .component-selected:not(.component-active) ::slotted(button),:host .component-selected:not(.component-active) ::slotted(a){background-color:var(--tds-header--basic-element-background-selected);padding-top:4px;border-bottom-style:solid;border-bottom-width:4px;border-bottom-color:var(--tds-nav-item-border-color-active)}\";\nconst TdsHeaderItemStyle0 = headerItemCss;\n\nconst TdsHeaderItem = class {\n    constructor(hostRef) {\n        registerInstance(this, hostRef);\n        this.active = false;\n        this.selected = false;\n    }\n    updateSlotted(searchPredicate, mutationCallback) {\n        const assignedElements = this.slotEl.assignedElements({ flatten: true });\n        const firstSlottedElement = assignedElements[0];\n        if (firstSlottedElement) {\n            const foundElement = dfs(firstSlottedElement, searchPredicate);\n            if (foundElement) {\n                mutationCallback(foundElement);\n            }\n        }\n    }\n    /**\n     * This function is needed because we can't use CSS selectors to style something in the light dom\n     */\n    updateSlottedElements() {\n        if (this.slotEl) {\n            const isIconOrSvg = (element) => element.tagName.toLowerCase() === 'tds-icon' || element.tagName.toLowerCase() === 'svg';\n            const addIconClass = (element) => element.classList.add('__tds-header-item-icon');\n            this.updateSlotted(isIconOrSvg, addIconClass);\n            const isImage = (element) => element.tagName.toLowerCase() === 'img';\n            const addImageClass = (element) => element.classList.add('__tds-header-item-image');\n            this.updateSlotted(isImage, addImageClass);\n        }\n    }\n    componentDidLoad() {\n        this.slotEl = this.host.shadowRoot.querySelector('slot');\n        this.updateSlottedElements();\n        this.slotEl.addEventListener('slotchange', this.updateSlottedElements);\n    }\n    render() {\n        return (h(Host, { key: 'e9db124a8c8140b9d0e0f948f46f7ad3629a7b65' }, h(\"tds-core-header-item\", { key: '84fd45fb90adb59ca67aee61970f74f756e359c5', class: {\n                'component-active': this.active,\n                'component-selected': this.selected,\n            } }, h(\"slot\", { key: '3ae05ca1b481bc0805ad348c461cfd4fcb99ba72' }))));\n    }\n    get host() { return getElement(this); }\n};\nTdsHeaderItem.style = TdsHeaderItemStyle0;\n\nexport { TdsCoreHeaderItem as tds_core_header_item, TdsHeaderItem as tds_header_item };\n"],"names":["dfs","parentNode","searchPredicate","pierceShadow","arguments","length","undefined","HTMLElement","childElements","HTMLSlotElement","assignedElements","flatten","Array","from","children","shadowRoot","push","foundElement","some","child","TdsCoreHeaderItem","constructor","hostRef","registerInstance","this","render","h","Host","key","class","style","TdsHeaderItem","active","selected","updateSlotted","mutationCallback","firstSlottedElement","slotEl","updateSlottedElements","isIconOrSvg","element","tagName","toLowerCase","addIconClass","classList","add","isImage","addImageClass","componentDidLoad","host","querySelector","addEventListener","getElement"],"sourceRoot":""}