{"version":3,"file":"static/js/1454.c1605bfa.chunk.js","mappings":"gIAQA,SAASA,EAAIC,EAAYC,GAAuC,IAAtBC,EAAYC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,IAAAA,UAAA,GAClD,GAAIH,aAAsBM,aAAeL,EAAgBD,GACrD,OAAOA,EAEX,MAAMO,EAAgBP,aAAsBQ,gBACtCR,EAAWS,iBAAiB,CAAEC,SAAS,IACvCC,MAAMC,KAAKZ,EAAWa,UACxBX,GAAgBF,aAAsBM,aAAeN,EAAWc,YAChEP,EAAcQ,QAAQJ,MAAMC,KAAKZ,EAAWc,WAAWD,WAE3D,IAAIG,EAAe,KAKnB,OAJAT,EAAcU,MAAMC,IAChBF,EAAejB,EAAImB,EAAOjB,EAAiBC,GACnB,OAAjBc,KAEJA,CACX,C,wECDA,MAAMG,EAAsBC,GAAYA,EAAQC,uBA8B1CC,EAA2CA,CAACF,EAASnB,IAjD3D,SAA0CmB,EAASnB,EAAiBsB,GAEhE,IAAIC,EAAUD,EAAmBH,GAEjC,KAAOI,GAAS,CAGZ,MAAMC,GAAc1B,EAAAA,EAAAA,GAAIyB,EAASvB,GAEjC,GAAIwB,EACA,OAAOA,EAGXD,EAAUD,EAAmBC,EACjC,CAEA,OAAO,IACX,CAgC+EE,CAAiCN,EAASnB,EAAiBkB,GAQpIQ,EAAoBC,IACtB,MAAMC,EAAUD,EAAGC,QAAQC,cACrBC,EAAOH,EAAGI,aAAa,QAC7B,MAAO,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAMC,SAASJ,IAAqB,YAATE,CAAkB,C,wFC5DvF,MAGMG,EAAwB,MAC1BC,WAAAA,CAAYC,IACRC,EAAAA,EAAAA,GAAiBC,KAAMF,GACvBE,KAAKC,oBAAiBlC,CAC1B,CACAmC,iBAAAA,GACI,MAAMC,EAAWH,KAAKI,KAChBC,GAAYrB,EAAAA,EAAAA,GAAyCmB,GAAWb,IAClE,MAAMgB,EAAIhB,EACV,OAAOD,EAAAA,EAAAA,GAAiBiB,EAAE,IAE1BD,EACAL,KAAKC,eAAiBI,EAGtBE,QAAQC,KAAK,qCAErB,CACAC,MAAAA,GACI,IAAIC,EACJ,MAAMC,EAAiB,CACnB,MAAS,2BACT,KAAQ,OACR,kBAAkD,QAA9BD,EAAKV,KAAKC,sBAAmC,IAAPS,OAAgB,EAASA,EAAGE,IAE1F,OAAQC,EAAAA,EAAAA,GAAEC,EAAAA,EAAM,CAAEC,IAAK,6CAA8CF,EAAAA,EAAAA,GAAE,MAAOG,OAAOC,OAAO,CAAEF,IAAK,4CAA8CJ,IAAiBE,EAAAA,EAAAA,GAAE,OAAQ,CAAEE,IAAK,8CACvL,CACA,QAAIX,GAAS,OAAOc,EAAAA,EAAAA,GAAWlB,KAAO,GAE1CJ,EAAsBuB,MAhCQ,6K","sources":["../node_modules/@scania/tegel/dist/esm/dfs-1e574d5f.js","../node_modules/@scania/tegel/dist/esm/isHeadingElement-8efea284.js","../node_modules/@scania/tegel/dist/esm/tds-header-launcher-grid.entry.js"],"sourcesContent":["/**\n * Recursively finds the first matching element or child based on a provided condition.\n *\n * @param {ParentNode} parentNode - The starting element or shadow root to search from.\n * @param {(el: HTMLElement) => boolean} searchPredicate - The condition to match the element, receives an HTMLElement and returns a boolean.\n * @param {boolean} [pierceShadow=false] - Whether to pierce through shadow DOM boundaries.\n * @returns {HTMLElement | null} - The first matching element or child, or null if none is found.\n */\nfunction dfs(parentNode, searchPredicate, pierceShadow = false) {\n    if (parentNode instanceof HTMLElement && searchPredicate(parentNode)) {\n        return parentNode;\n    }\n    const childElements = parentNode instanceof HTMLSlotElement\n        ? parentNode.assignedElements({ flatten: true })\n        : Array.from(parentNode.children);\n    if (pierceShadow && parentNode instanceof HTMLElement && parentNode.shadowRoot) {\n        childElements.push(...Array.from(parentNode.shadowRoot.children));\n    }\n    let foundElement = null;\n    childElements.some((child) => {\n        foundElement = dfs(child, searchPredicate, pierceShadow);\n        return foundElement !== null;\n    });\n    return foundElement;\n}\n\nexport { dfs as d };\n","import { d as dfs } from './dfs-1e574d5f.js';\n\n// A higher-order function to find the nested child of siblings matching a predicate,\n// based on a sibling traversal function (getNextSibling or getPreviousSibling).\nfunction getNestedChildOfSiblingsMatching(element, searchPredicate, siblingTraversalFn) {\n    // Start with the sibling of the provided element.\n    let sibling = siblingTraversalFn(element);\n    // Iterate through the siblings until there are no more siblings.\n    while (sibling) {\n        // Use the dfs helper function to find the deeply nested child\n        // that matches the given criteria within the current sibling.\n        const nestedChild = dfs(sibling, searchPredicate);\n        // If a matching deeply nested child is found, return it.\n        if (nestedChild) {\n            return nestedChild;\n        }\n        // Move on to the next sibling.\n        sibling = siblingTraversalFn(sibling);\n    }\n    // If no matching deeply nested child is found, return null.\n    return null;\n}\n\nconst getPreviousSibling = (element) => element.previousElementSibling;\n\n/**\n * Searches for a previous sibling element that has a nested child element matching the provided search predicate.\n * The search starts from the given element and proceeds to its previous siblings, diving deep into each sibling's descendants.\n *\n * @param {HTMLElement} element - The starting element to begin the search from.\n * @param {(el: HTMLElement) => boolean} searchPredicate - A predicate function that checks if an element matches the desired condition.\n * @returns {HTMLElement | null} - The matching nested child element, or null if no matching element is found.\n *\n * @example\n * // HTML structure:\n * // <div>\n * //   <h1>Heading 1</h1>\n * //   <ul role=\"list\">\n * //     <li>Item 1</li>\n * //   </ul>\n * // </div>\n * // <div>\n * //   <h2>Heading 2</h2>\n * //   <ul role=\"list\">\n * //     <li>Item 2</li>\n * //   </ul>\n * // </div>\n *\n * const searchPredicate = (el) => el.tagName.toLowerCase() === 'h2';\n * const startingElement = document.querySelector('[role=\"list\"]');\n * const headingEl = getPreviousNestedChildOfSiblingsMatching(startingElement, searchPredicate);\n * console.log(headingEl); // Logs the <h2>Heading 2</h2> element\n */\nconst getPreviousNestedChildOfSiblingsMatching = (element, searchPredicate) => getNestedChildOfSiblingsMatching(element, searchPredicate, getPreviousSibling);\n\n/**\n * Checks if the given element is a heading element (h1-h6) or has a role of \"heading\".\n *\n * @param {HTMLElement} el - The element to check.\n * @returns {boolean} - True if the element is a heading element, false otherwise.\n */\nconst isHeadingElement = (el) => {\n    const tagName = el.tagName.toLowerCase();\n    const role = el.getAttribute('role');\n    return ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(tagName) || role === 'heading';\n};\n\nexport { getPreviousNestedChildOfSiblingsMatching as g, isHeadingElement as i };\n","import { r as registerInstance, h, H as Host, g as getElement } from './index-529974bd.js';\nimport { g as getPreviousNestedChildOfSiblingsMatching, i as isHeadingElement } from './isHeadingElement-8efea284.js';\nimport './dfs-1e574d5f.js';\n\nconst headerLauncherGridCss = \".tds-header-launcher-grid{box-sizing:border-box;padding:12px;margin:0;list-style:none;width:100%;display:grid;grid-template-columns:1fr 1fr 1fr;gap:4px;border-radius:none}\";\nconst TdsHeaderLauncherGridStyle0 = headerLauncherGridCss;\n\nconst TdsHeaderLauncherGrid = class {\n    constructor(hostRef) {\n        registerInstance(this, hostRef);\n        this.headingElement = undefined;\n    }\n    componentWillLoad() {\n        const listRoot = this.host;\n        const headingEl = getPreviousNestedChildOfSiblingsMatching(listRoot, (el) => {\n            const e = el;\n            return isHeadingElement(e);\n        });\n        if (headingEl) {\n            this.headingElement = headingEl;\n        }\n        else {\n            console.warn('Heading element for list not found');\n        }\n    }\n    render() {\n        var _a;\n        const listAttributes = {\n            'class': 'tds-header-launcher-grid',\n            'role': 'list',\n            'aria-labelledby': (_a = this.headingElement) === null || _a === void 0 ? void 0 : _a.id,\n        };\n        return (h(Host, { key: 'f61e4a271a143bcdbfe0c56ae8d687c00e7e23dc' }, h(\"div\", Object.assign({ key: '4403ceb73e4410ed6d5f33cfd91bcdbe6cace263' }, listAttributes), h(\"slot\", { key: 'f43fea428cadb07fbdcc5247cdcc4bf2f3b0652c' }))));\n    }\n    get host() { return getElement(this); }\n};\nTdsHeaderLauncherGrid.style = TdsHeaderLauncherGridStyle0;\n\nexport { TdsHeaderLauncherGrid as tds_header_launcher_grid };\n"],"names":["dfs","parentNode","searchPredicate","pierceShadow","arguments","length","undefined","HTMLElement","childElements","HTMLSlotElement","assignedElements","flatten","Array","from","children","shadowRoot","push","foundElement","some","child","getPreviousSibling","element","previousElementSibling","getPreviousNestedChildOfSiblingsMatching","siblingTraversalFn","sibling","nestedChild","getNestedChildOfSiblingsMatching","isHeadingElement","el","tagName","toLowerCase","role","getAttribute","includes","TdsHeaderLauncherGrid","constructor","hostRef","registerInstance","this","headingElement","componentWillLoad","listRoot","host","headingEl","e","console","warn","render","_a","listAttributes","id","h","Host","key","Object","assign","getElement","style"],"sourceRoot":""}