{"version":3,"file":"static/js/4505.4e92848a.chunk.js","mappings":"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","sources":["../node_modules/@scania/tegel/dist/esm/dfs-1e574d5f.js","../node_modules/@scania/tegel/dist/esm/isHeadingElement-8efea284.js","../node_modules/@scania/tegel/dist/esm/tds-header-dropdown-list.entry.js"],"sourcesContent":["/**\n * Recursively finds the first matching element or child based on a provided condition.\n *\n * @param {ParentNode} parentNode - The starting element or shadow root to search from.\n * @param {(el: HTMLElement) => boolean} searchPredicate - The condition to match the element, receives an HTMLElement and returns a boolean.\n * @param {boolean} [pierceShadow=false] - Whether to pierce through shadow DOM boundaries.\n * @returns {HTMLElement | null} - The first matching element or child, or null if none is found.\n */\nfunction dfs(parentNode, searchPredicate, pierceShadow = false) {\n    if (parentNode instanceof HTMLElement && searchPredicate(parentNode)) {\n        return parentNode;\n    }\n    const childElements = parentNode instanceof HTMLSlotElement\n        ? parentNode.assignedElements({ flatten: true })\n        : Array.from(parentNode.children);\n    if (pierceShadow && parentNode instanceof HTMLElement && parentNode.shadowRoot) {\n        childElements.push(...Array.from(parentNode.shadowRoot.children));\n    }\n    let foundElement = null;\n    childElements.some((child) => {\n        foundElement = dfs(child, searchPredicate, pierceShadow);\n        return foundElement !== null;\n    });\n    return foundElement;\n}\n\nexport { dfs as d };\n","import { d as dfs } from './dfs-1e574d5f.js';\n\n// A higher-order function to find the nested child of siblings matching a predicate,\n// based on a sibling traversal function (getNextSibling or getPreviousSibling).\nfunction getNestedChildOfSiblingsMatching(element, searchPredicate, siblingTraversalFn) {\n    // Start with the sibling of the provided element.\n    let sibling = siblingTraversalFn(element);\n    // Iterate through the siblings until there are no more siblings.\n    while (sibling) {\n        // Use the dfs helper function to find the deeply nested child\n        // that matches the given criteria within the current sibling.\n        const nestedChild = dfs(sibling, searchPredicate);\n        // If a matching deeply nested child is found, return it.\n        if (nestedChild) {\n            return nestedChild;\n        }\n        // Move on to the next sibling.\n        sibling = siblingTraversalFn(sibling);\n    }\n    // If no matching deeply nested child is found, return null.\n    return null;\n}\n\nconst getPreviousSibling = (element) => element.previousElementSibling;\n\n/**\n * Searches for a previous sibling element that has a nested child element matching the provided search predicate.\n * The search starts from the given element and proceeds to its previous siblings, diving deep into each sibling's descendants.\n *\n * @param {HTMLElement} element - The starting element to begin the search from.\n * @param {(el: HTMLElement) => boolean} searchPredicate - A predicate function that checks if an element matches the desired condition.\n * @returns {HTMLElement | null} - The matching nested child element, or null if no matching element is found.\n *\n * @example\n * // HTML structure:\n * // <div>\n * //   <h1>Heading 1</h1>\n * //   <ul role=\"list\">\n * //     <li>Item 1</li>\n * //   </ul>\n * // </div>\n * // <div>\n * //   <h2>Heading 2</h2>\n * //   <ul role=\"list\">\n * //     <li>Item 2</li>\n * //   </ul>\n * // </div>\n *\n * const searchPredicate = (el) => el.tagName.toLowerCase() === 'h2';\n * const startingElement = document.querySelector('[role=\"list\"]');\n * const headingEl = getPreviousNestedChildOfSiblingsMatching(startingElement, searchPredicate);\n * console.log(headingEl); // Logs the <h2>Heading 2</h2> element\n */\nconst getPreviousNestedChildOfSiblingsMatching = (element, searchPredicate) => getNestedChildOfSiblingsMatching(element, searchPredicate, getPreviousSibling);\n\n/**\n * Checks if the given element is a heading element (h1-h6) or has a role of \"heading\".\n *\n * @param {HTMLElement} el - The element to check.\n * @returns {boolean} - True if the element is a heading element, false otherwise.\n */\nconst isHeadingElement = (el) => {\n    const tagName = el.tagName.toLowerCase();\n    const role = el.getAttribute('role');\n    return ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(tagName) || role === 'heading';\n};\n\nexport { getPreviousNestedChildOfSiblingsMatching as g, isHeadingElement as i };\n","import { r as registerInstance, h, H as Host, g as getElement } from './index-529974bd.js';\nimport { g as getPreviousNestedChildOfSiblingsMatching, i as isHeadingElement } from './isHeadingElement-8efea284.js';\nimport './dfs-1e574d5f.js';\n\nconst headerDropdownListCss = \":host{display:block;width:190px;padding:0;margin:0;list-style:none;border-radius:unset;background-color:var(--tds-header-app-launcher-menu-bg)}@media all and (max-width: 384px){:host{width:100vw}}:host([size=lg]){width:320px}\";\nconst TdsHeaderDropdownListStyle0 = headerDropdownListCss;\n\nconst TdsHeaderDropdownList = class {\n    constructor(hostRef) {\n        registerInstance(this, hostRef);\n        // A Map to store the slots and their associated slotchange listeners.\n        this.slotListeners = new Map();\n        this.size = 'md';\n        this.headingElement = undefined;\n    }\n    componentWillLoad() {\n        const { children } = this.host;\n        // Set the size prop for each child, if they have such a property\n        for (let i = 0; i < children.length; i++) {\n            const child = children[i];\n            if ('size' in child) {\n                child.size = this.size;\n            }\n        }\n        let listRoot = this.host;\n        if (this.host.parentElement.tagName.toLowerCase() === 'tds-header-launcher-list') {\n            listRoot = this.host.parentElement;\n        }\n        const headingEl = getPreviousNestedChildOfSiblingsMatching(listRoot, isHeadingElement);\n        if (headingEl) {\n            this.headingElement = headingEl;\n        }\n        else {\n            console.warn('Heading element for list not found');\n        }\n    }\n    componentDidLoad() {\n        this.host.shadowRoot.querySelectorAll('slot').forEach((slot) => {\n            // Add the slotchange event listener.\n            const onSlotChange = (e) => {\n                this.processAssignedElements(e.target);\n            };\n            slot.addEventListener('slotchange', onSlotChange);\n            onSlotChange({ target: slot });\n            // Store the slot and its listener in the Map.\n            this.slotListeners.set(slot, onSlotChange);\n        });\n    }\n    processAssignedElements(slot) {\n        const nodes = slot.assignedElements();\n        nodes.forEach((node) => {\n            // Add a listitem role to the assigned element if needed.\n            if (node.tagName.toLowerCase() !== 'li' &&\n                node.tagName.toLowerCase() !== 'slot' &&\n                node.getAttribute('role') !== 'listitem') {\n                node.setAttribute('role', 'listitem');\n            }\n            // If the assigned element is a slot, process its assigned elements recursively.\n            if (node.tagName.toLowerCase() === 'slot') {\n                this.processAssignedElements(node);\n            }\n        });\n    }\n    disconnectedCallback() {\n        this.slotListeners.forEach((listener, slot) => {\n            // Remove the slotchange event listener and delete the entry from the Map.\n            slot.removeEventListener('slotchange', listener);\n            this.slotListeners.delete(slot);\n        });\n    }\n    render() {\n        var _a;\n        const attributes = {\n            'role': 'list',\n            'aria-labelledby': (_a = this.headingElement) === null || _a === void 0 ? void 0 : _a.id,\n        };\n        return (h(Host, Object.assign({ key: '1811afd66a144c882c0d2d29d3bb01df601911cb' }, attributes), h(\"slot\", { key: '4b1cee3cd03339a3371f87785b87eae665d76a47' })));\n    }\n    get host() { return getElement(this); }\n};\nTdsHeaderDropdownList.style = TdsHeaderDropdownListStyle0;\n\nexport { TdsHeaderDropdownList as tds_header_dropdown_list };\n"],"names":["dfs","parentNode","searchPredicate","pierceShadow","arguments","length","undefined","HTMLElement","childElements","HTMLSlotElement","assignedElements","flatten","Array","from","children","shadowRoot","push","foundElement","some","child","getPreviousSibling","element","previousElementSibling","getPreviousNestedChildOfSiblingsMatching","siblingTraversalFn","sibling","nestedChild","getNestedChildOfSiblingsMatching","isHeadingElement","el","tagName","toLowerCase","role","getAttribute","includes","TdsHeaderDropdownList","constructor","hostRef","registerInstance","this","slotListeners","Map","size","headingElement","componentWillLoad","host","i","listRoot","parentElement","headingEl","console","warn","componentDidLoad","querySelectorAll","forEach","slot","onSlotChange","e","processAssignedElements","target","addEventListener","set","node","setAttribute","disconnectedCallback","listener","removeEventListener","delete","render","_a","attributes","id","h","Host","Object","assign","key","getElement","style"],"sourceRoot":""}